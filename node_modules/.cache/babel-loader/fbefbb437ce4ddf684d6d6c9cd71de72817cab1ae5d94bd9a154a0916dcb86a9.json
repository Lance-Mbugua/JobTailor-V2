{"ast":null,"code":"// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce((combinedHeaders, currentHeaders) => ({\n    ...combinedHeaders,\n    ...(currentHeaders != null ? currentHeaders : {})\n  }), {});\n}\n\n// src/convert-async-iterator-to-readable-stream.ts\nfunction convertAsyncIteratorToReadableStream(iterator) {\n  return new ReadableStream({\n    /**\r\n     * Called when the consumer wants to pull more data from the stream.\r\n     *\r\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\r\n     * @returns {Promise<void>}\r\n     */\n    async pull(controller) {\n      try {\n        const {\n          value,\n          done\n        } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\r\n     * Called when the consumer cancels the stream.\r\n     */\n    cancel() {}\n  });\n}\n\n// src/delay.ts\nasync function delay(delayInMs) {\n  return delayInMs == null ? Promise.resolve() : new Promise(resolve2 => setTimeout(resolve2, delayInMs));\n}\n\n// src/event-source-parser-stream.ts\nfunction createEventSourceParserStream() {\n  let buffer = \"\";\n  let event = void 0;\n  let data = [];\n  let lastEventId = void 0;\n  let retry = void 0;\n  function parseLine(line, controller) {\n    if (line === \"\") {\n      dispatchEvent(controller);\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      return;\n    }\n    const colonIndex = line.indexOf(\":\");\n    if (colonIndex === -1) {\n      handleField(line, \"\");\n      return;\n    }\n    const field = line.slice(0, colonIndex);\n    const valueStart = colonIndex + 1;\n    const value = valueStart < line.length && line[valueStart] === \" \" ? line.slice(valueStart + 1) : line.slice(valueStart);\n    handleField(field, value);\n  }\n  function dispatchEvent(controller) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join(\"\\n\"),\n        id: lastEventId,\n        retry\n      });\n      data = [];\n      event = void 0;\n      retry = void 0;\n    }\n  }\n  function handleField(field, value) {\n    switch (field) {\n      case \"event\":\n        event = value;\n        break;\n      case \"data\":\n        data.push(value);\n        break;\n      case \"id\":\n        lastEventId = value;\n        break;\n      case \"retry\":\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n  return new TransformStream({\n    transform(chunk, controller) {\n      const {\n        lines,\n        incompleteLine\n      } = splitLines(buffer, chunk);\n      buffer = incompleteLine;\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    }\n  });\n}\nfunction splitLines(buffer, chunk) {\n  const lines = [];\n  let currentLine = buffer;\n  for (let i = 0; i < chunk.length;) {\n    const char = chunk[i++];\n    if (char === \"\\n\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n    } else if (char === \"\\r\") {\n      lines.push(currentLine);\n      currentLine = \"\";\n      if (chunk[i + 1] === \"\\n\") {\n        i++;\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n  return {\n    lines,\n    incompleteLine: currentLine\n  };\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\nimport { InvalidArgumentError } from \"@ai-sdk/provider\";\nimport { customAlphabet } from \"nanoid/non-secure\";\nvar createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return size => `${prefix}${separator}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/get-from-api.ts\nimport { APICallError } from \"@ai-sdk/provider\";\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(Object.entries(record).filter(([_key, value]) => value != null));\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/get-from-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar getFromApi = async ({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {}\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {}\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {}\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {}\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {}\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/load-api-key.ts\nimport { LoadAPIKeyError } from \"@ai-sdk/provider\";\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/load-setting.ts\nimport { LoadSettingError } from \"@ai-sdk/provider\";\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\nimport { JSONParseError, TypeValidationError as TypeValidationError2 } from \"@ai-sdk/provider\";\nimport SecureJSON from \"secure-json-parse\";\n\n// src/validate-types.ts\nimport { TypeValidationError } from \"@ai-sdk/provider\";\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return {\n    [validatorSymbol]: true,\n    validate\n  };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? {\n      success: true,\n      value: result.data\n    } : {\n      success: false,\n      error: result.error\n    };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({\n    value,\n    schema: inputSchema\n  });\n  if (!result.success) {\n    throw TypeValidationError.wrap({\n      value,\n      cause: result.error\n    });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return {\n        success: true,\n        value\n      };\n    }\n    const result = validator2.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: TypeValidationError.wrap({\n        value,\n        cause: result.error\n      })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({\n        value,\n        cause: error\n      })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = SecureJSON.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({\n      value,\n      schema\n    });\n  } catch (error) {\n    if (JSONParseError.isInstance(error) || TypeValidationError2.isInstance(error)) {\n      throw error;\n    }\n    throw new JSONParseError({\n      text,\n      cause: error\n    });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = SecureJSON.parse(text);\n    if (schema == null) {\n      return {\n        success: true,\n        value,\n        rawValue: value\n      };\n    }\n    const validationResult = safeValidateTypes({\n      value,\n      schema\n    });\n    return validationResult.success ? {\n      ...validationResult,\n      rawValue: value\n    } : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error) ? error : new JSONParseError({\n        text,\n        cause: error\n      })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n// src/parse-provider-options.ts\nimport { InvalidArgumentError as InvalidArgumentError2 } from \"@ai-sdk/provider\";\nfunction parseProviderOptions({\n  provider,\n  providerOptions,\n  schema\n}) {\n  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {\n    return void 0;\n  }\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema\n  });\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError2({\n      argument: \"providerOptions\",\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error\n    });\n  }\n  return parsedProviderOptions.value;\n}\n\n// src/post-to-api.ts\nimport { APICallError as APICallError2 } from \"@ai-sdk/provider\";\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError2.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError2({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError2.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError2({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new APICallError2({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/resolve.ts\nasync function resolve(value) {\n  if (typeof value === \"function\") {\n    value = value();\n  }\n  return Promise.resolve(value);\n}\n\n// src/response-handler.ts\nimport { APICallError as APICallError3, EmptyResponseBodyError } from \"@ai-sdk/provider\";\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({\n  response,\n  url,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError3({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError3({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError3({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = chunkSchema => async ({\n  response\n}) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(createEventSourceParserStream()).pipeThrough(new TransformStream({\n      transform({\n        data\n      }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(safeParseJSON({\n          text: data,\n          schema: chunkSchema\n        }));\n      }\n    }))\n  };\n};\nvar createJsonStreamResponseHandler = chunkSchema => async ({\n  response\n}) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n      transform(chunkText, controller) {\n        if (chunkText.endsWith(\"\\n\")) {\n          controller.enqueue(safeParseJSON({\n            text: buffer + chunkText,\n            schema: chunkSchema\n          }));\n          buffer = \"\";\n        } else {\n          buffer += chunkText;\n        }\n      }\n    }))\n  };\n};\nvar createJsonResponseHandler = responseSchema => async ({\n  response,\n  url,\n  requestBodyValues\n}) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new APICallError3({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar createBinaryResponseHandler = () => async ({\n  response,\n  url,\n  requestBodyValues\n}) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (!response.body) {\n    throw new APICallError3({\n      message: \"Response body is empty\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0\n    });\n  }\n  try {\n    const buffer = await response.arrayBuffer();\n    return {\n      responseHeaders,\n      value: new Uint8Array(buffer)\n    };\n  } catch (error) {\n    throw new APICallError3({\n      message: \"Failed to read response as array buffer\",\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody: void 0,\n      cause: error\n    });\n  }\n};\nvar createStatusCodeErrorResponseHandler = () => async ({\n  response,\n  url,\n  requestBodyValues\n}) => {\n  const responseHeaders = extractResponseHeaders(response);\n  const responseBody = await response.text();\n  return {\n    responseHeaders,\n    value: new APICallError3({\n      message: response.statusText,\n      url,\n      requestBodyValues,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody\n    })\n  };\n};\n\n// src/uint8-utils.ts\nvar {\n  btoa,\n  atob\n} = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\nexport { asValidator, combineHeaders, convertAsyncIteratorToReadableStream, convertBase64ToUint8Array, convertUint8ArrayToBase64, createBinaryResponseHandler, createEventSourceParserStream, createEventSourceResponseHandler, createIdGenerator, createJsonErrorResponseHandler, createJsonResponseHandler, createJsonStreamResponseHandler, createStatusCodeErrorResponseHandler, delay, extractResponseHeaders, generateId, getErrorMessage, getFromApi, isAbortError, isParsableJson, isValidator, loadApiKey, loadOptionalSetting, loadSetting, parseJSON, parseProviderOptions, postJsonToApi, postToApi, removeUndefinedEntries, resolve, safeParseJSON, safeValidateTypes, validateTypes, validator, validatorSymbol, withoutTrailingSlash, zodValidator };","map":{"version":3,"names":["combineHeaders","headers","reduce","combinedHeaders","currentHeaders","convertAsyncIteratorToReadableStream","iterator","ReadableStream","pull","controller","value","done","next","close","enqueue","error","cancel","delay","delayInMs","Promise","resolve","resolve2","setTimeout","createEventSourceParserStream","buffer","event","data","lastEventId","retry","parseLine","line","dispatchEvent","startsWith","colonIndex","indexOf","handleField","field","slice","valueStart","length","join","id","push","parsedRetry","parseInt","isNaN","TransformStream","transform","chunk","lines","incompleteLine","splitLines","i","flush","currentLine","char","extractResponseHeaders","response","forEach","key","InvalidArgumentError","customAlphabet","createIdGenerator","prefix","size","defaultSize","alphabet","separator","generator","includes","argument","message","generateId","getErrorMessage","Error","JSON","stringify","APICallError","removeUndefinedEntries","record","Object","fromEntries","entries","filter","_key","isAbortError","name","getOriginalFetch","globalThis","fetch","getFromApi","url","successfulResponseHandler","failedResponseHandler","abortSignal","method","signal","responseHeaders","ok","errorInformation","requestBodyValues","isInstance","cause","statusCode","status","TypeError","isRetryable","LoadAPIKeyError","loadApiKey","apiKey","environmentVariableName","apiKeyParameterName","description","process","env","loadOptionalSetting","settingValue","LoadSettingError","loadSetting","settingName","JSONParseError","TypeValidationError","TypeValidationError2","SecureJSON","validatorSymbol","Symbol","for","validator","validate","isValidator","asValidator","zodValidator","zodSchema","result","safeParse","success","validateTypes","schema","inputSchema","safeValidateTypes","wrap","validator2","parseJSON","text","parse","safeParseJSON","rawValue","validationResult","isParsableJson","input","e","InvalidArgumentError2","parseProviderOptions","provider","providerOptions","parsedProviderOptions","APICallError2","getOriginalFetch2","postJsonToApi","body","postToApi","content","values","APICallError3","EmptyResponseBodyError","createJsonErrorResponseHandler","errorSchema","errorToMessage","responseBody","trim","statusText","parsedError","parseError","createEventSourceResponseHandler","chunkSchema","pipeThrough","TextDecoderStream","createJsonStreamResponseHandler","chunkText","endsWith","createJsonResponseHandler","responseSchema","parsedResult","createBinaryResponseHandler","arrayBuffer","Uint8Array","createStatusCodeErrorResponseHandler","btoa","atob","convertBase64ToUint8Array","base64String","base64Url","replace","latin1string","from","byte","codePointAt","convertUint8ArrayToBase64","array","String","fromCodePoint","withoutTrailingSlash"],"sources":["C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\combine-headers.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\convert-async-iterator-to-readable-stream.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\delay.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\event-source-parser-stream.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\extract-response-headers.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\generate-id.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\get-error-message.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\get-from-api.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\remove-undefined-entries.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\is-abort-error.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\load-api-key.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\load-optional-setting.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\load-setting.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\parse-json.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\validate-types.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\validator.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\parse-provider-options.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\post-to-api.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\resolve.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\response-handler.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\uint8-utils.ts","C:\\Users\\owner\\JobTailor V2\\frontend\\node_modules\\@ai-sdk\\provider-utils\\src\\without-trailing-slash.ts"],"sourcesContent":["export function combineHeaders(\n  ...headers: Array<Record<string, string | undefined> | undefined>\n): Record<string, string | undefined> {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...(currentHeaders ?? {}),\n    }),\n    {},\n  ) as Record<string, string | undefined>;\n}\n","/**\n * Converts an AsyncIterator to a ReadableStream.\n *\n * @template T - The type of elements produced by the AsyncIterator.\n * @param { <T>} iterator - The AsyncIterator to convert.\n * @returns {ReadableStream<T>} - A ReadableStream that provides the same data as the AsyncIterator.\n */\nexport function convertAsyncIteratorToReadableStream<T>(\n  iterator: AsyncIterator<T>,\n): ReadableStream<T> {\n  return new ReadableStream<T>({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await iterator.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {},\n  });\n}\n","/**\n * Creates a Promise that resolves after a specified delay\n * @param delayInMs - The delay duration in milliseconds. If null or undefined, resolves immediately.\n * @returns A Promise that resolves after the specified delay\n */\nexport async function delay(delayInMs?: number | null): Promise<void> {\n  return delayInMs == null\n    ? Promise.resolve()\n    : new Promise(resolve => setTimeout(resolve, delayInMs));\n}\n","export type EventSourceChunk = {\n  event: string | undefined;\n  data: string;\n  id?: string;\n  retry?: number;\n};\n\nexport function createEventSourceParserStream() {\n  let buffer = '';\n  let event: string | undefined = undefined;\n  let data: string[] = [];\n  let lastEventId: string | undefined = undefined;\n  let retry: number | undefined = undefined;\n\n  function parseLine(\n    line: string,\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    // Empty line means dispatch the event\n    if (line === '') {\n      dispatchEvent(controller);\n      return;\n    }\n\n    // Comments start with colon\n    if (line.startsWith(':')) {\n      return;\n    }\n\n    // Field parsing\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      // field with no value\n      handleField(line, '');\n      return;\n    }\n\n    const field = line.slice(0, colonIndex);\n    // If there's a space after the colon, it should be ignored\n    const valueStart = colonIndex + 1;\n    const value =\n      valueStart < line.length && line[valueStart] === ' '\n        ? line.slice(valueStart + 1)\n        : line.slice(valueStart);\n\n    handleField(field, value);\n  }\n\n  function dispatchEvent(\n    controller: TransformStreamDefaultController<EventSourceChunk>,\n  ) {\n    if (data.length > 0) {\n      controller.enqueue({\n        event,\n        data: data.join('\\n'),\n        id: lastEventId,\n        retry,\n      });\n\n      // Reset data but keep lastEventId as per spec\n      data = [];\n      event = undefined;\n      retry = undefined;\n    }\n  }\n\n  function handleField(field: string, value: string) {\n    switch (field) {\n      case 'event':\n        event = value;\n        break;\n      case 'data':\n        data.push(value);\n        break;\n      case 'id':\n        lastEventId = value;\n        break;\n      case 'retry':\n        const parsedRetry = parseInt(value, 10);\n        if (!isNaN(parsedRetry)) {\n          retry = parsedRetry;\n        }\n        break;\n    }\n  }\n\n  return new TransformStream<string, EventSourceChunk>({\n    transform(chunk, controller) {\n      const { lines, incompleteLine } = splitLines(buffer, chunk);\n\n      buffer = incompleteLine;\n\n      // using for loop for performance\n      for (let i = 0; i < lines.length; i++) {\n        parseLine(lines[i], controller);\n      }\n    },\n\n    flush(controller) {\n      parseLine(buffer, controller);\n      dispatchEvent(controller);\n    },\n  });\n}\n\n// performance: send in already scanned buffer separately, do not scan again\nfunction splitLines(buffer: string, chunk: string) {\n  const lines: Array<string> = [];\n  let currentLine = buffer;\n\n  // using for loop for performance\n  for (let i = 0; i < chunk.length; ) {\n    const char = chunk[i++];\n\n    // order is performance-optimized\n    if (char === '\\n') {\n      // Standalone LF\n      lines.push(currentLine);\n      currentLine = '';\n    } else if (char === '\\r') {\n      lines.push(currentLine);\n      currentLine = '';\n\n      if (chunk[i + 1] === '\\n') {\n        i++; // CRLF case: Skip the LF character\n      }\n    } else {\n      currentLine += char;\n    }\n  }\n\n  return { lines, incompleteLine: currentLine };\n}\n","/**\nExtracts the headers from a response object and returns them as a key-value object.\n\n@param response - The response object to extract headers from.\n@returns The headers as a key-value object.\n*/\nexport function extractResponseHeaders(\n  response: Response,\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { customAlphabet } from 'nanoid/non-secure';\n\n/**\nCreates an ID generator.\nThe total length of the ID is the sum of the prefix, separator, and random part length.\nNon-secure.\n\n@param alphabet - The alphabet to use for the ID. Default: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.\n@param prefix - The prefix of the ID to generate. Default: ''.\n@param separator - The separator between the prefix and the random part of the ID. Default: '-'.\n@param size - The size of the random part of the ID to generate. Default: 16.\n */\n// TODO 5.0 breaking change: change the return type to IDGenerator\nexport const createIdGenerator = ({\n  prefix,\n  size: defaultSize = 16,\n  alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n  separator = '-',\n}: {\n  prefix?: string;\n  separator?: string;\n  size?: number;\n  alphabet?: string;\n} = {}): ((size?: number) => string) => {\n  const generator = customAlphabet(alphabet, defaultSize);\n\n  if (prefix == null) {\n    return generator;\n  }\n\n  // check that the prefix is not part of the alphabet (otherwise prefix checking can fail randomly)\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: 'separator',\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`,\n    });\n  }\n\n  return size => `${prefix}${separator}${generator(size)}`;\n};\n\n/**\nA function that generates an ID.\n */\nexport type IDGenerator = () => string;\n\n/**\nGenerates a 16-character random string to use for IDs. Not secure.\n\n@param size - The size of the ID to generate. Default: 16.\n */\nexport const generateId = createIdGenerator();\n","export function getErrorMessage(error: unknown | undefined) {\n  if (error == null) {\n    return 'unknown error';\n  }\n\n  if (typeof error === 'string') {\n    return error;\n  }\n\n  if (error instanceof Error) {\n    return error.message;\n  }\n\n  return JSON.stringify(error);\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { FetchFunction } from './fetch-function';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\nimport { isAbortError } from './is-abort-error';\nimport { extractResponseHeaders } from './extract-response-headers';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const getFromApi = async <T>({\n  url,\n  headers = {},\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: removeUndefinedEntries(headers),\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: {},\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: {},\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: {},\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: {},\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n      if (cause != null) {\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          isRetryable: true,\n          requestBodyValues: {},\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","/**\n * Removes entries from a record where the value is null or undefined.\n * @param record - The input object whose entries may be null or undefined.\n * @returns A new object containing only entries with non-null and non-undefined values.\n */\nexport function removeUndefinedEntries<T>(\n  record: Record<string, T | undefined>,\n): Record<string, T> {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null),\n  ) as Record<string, T>;\n}\n","export function isAbortError(error: unknown): error is Error {\n  return (\n    error instanceof Error &&\n    (error.name === 'AbortError' || error.name === 'TimeoutError')\n  );\n}\n","import { LoadAPIKeyError } from '@ai-sdk/provider';\n\nexport function loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = 'apiKey',\n  description,\n}: {\n  apiKey: string | undefined;\n  environmentVariableName: string;\n  apiKeyParameterName?: string;\n  description: string;\n}): string {\n  if (typeof apiKey === 'string') {\n    return apiKey;\n  }\n\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`,\n    });\n  }\n\n  apiKey = process.env[environmentVariableName];\n\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof apiKey !== 'string') {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return apiKey;\n}\n","/**\n * Loads an optional `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @returns The setting value.\n */\nexport function loadOptionalSetting({\n  settingValue,\n  environmentVariableName,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n}): string | undefined {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null || typeof process === 'undefined') {\n    return undefined;\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null || typeof settingValue !== 'string') {\n    return undefined;\n  }\n\n  return settingValue;\n}\n","import { LoadSettingError } from '@ai-sdk/provider';\n\n/**\n * Loads a `string` setting from the environment or a parameter.\n *\n * @param settingValue - The setting value.\n * @param environmentVariableName - The environment variable name.\n * @param settingName - The setting name.\n * @param description - The description of the setting.\n * @returns The setting value.\n */\nexport function loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description,\n}: {\n  settingValue: string | undefined;\n  environmentVariableName: string;\n  settingName: string;\n  description: string;\n}): string {\n  if (typeof settingValue === 'string') {\n    return settingValue;\n  }\n\n  if (settingValue != null) {\n    throw new LoadSettingError({\n      message: `${description} setting must be a string.`,\n    });\n  }\n\n  if (typeof process === 'undefined') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter. ` +\n        `Environment variables is not supported in this environment.`,\n    });\n  }\n\n  settingValue = process.env[environmentVariableName];\n\n  if (settingValue == null) {\n    throw new LoadSettingError({\n      message:\n        `${description} setting is missing. ` +\n        `Pass it using the '${settingName}' parameter ` +\n        `or the ${environmentVariableName} environment variable.`,\n    });\n  }\n\n  if (typeof settingValue !== 'string') {\n    throw new LoadSettingError({\n      message:\n        `${description} setting must be a string. ` +\n        `The value of the ${environmentVariableName} environment variable is not a string.`,\n    });\n  }\n\n  return settingValue;\n}\n","import {\n  JSONParseError,\n  JSONValue,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport SecureJSON from 'secure-json-parse';\nimport { ZodSchema } from 'zod';\nimport { safeValidateTypes, validateTypes } from './validate-types';\nimport { Validator } from './validator';\n\n/**\n * Parses a JSON string into an unknown object.\n *\n * @param text - The JSON string to parse.\n * @returns {JSONValue} - The parsed JSON object.\n */\nexport function parseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): JSONValue;\n/**\n * Parses a JSON string into a strongly-typed object using the provided schema.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns {T} - The parsed object.\n */\nexport function parseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): T;\nexport function parseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): T {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return value;\n    }\n\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (\n      JSONParseError.isInstance(error) ||\n      TypeValidationError.isInstance(error)\n    ) {\n      throw error;\n    }\n\n    throw new JSONParseError({ text, cause: error });\n  }\n}\n\nexport type ParseResult<T> =\n  | { success: true; value: T; rawValue: unknown }\n  | { success: false; error: JSONParseError | TypeValidationError };\n\n/**\n * Safely parses a JSON string and returns the result as an object of type `unknown`.\n *\n * @param text - The JSON string to parse.\n * @returns {object} Either an object with `success: true` and the parsed data, or an object with `success: false` and the error that occurred.\n */\nexport function safeParseJSON(options: {\n  text: string;\n  schema?: undefined;\n}): ParseResult<JSONValue>;\n/**\n * Safely parses a JSON string into a strongly-typed object, using a provided schema to validate the object.\n *\n * @template T - The type of the object to parse the JSON into.\n * @param {string} text - The JSON string to parse.\n * @param {Validator<T>} schema - The schema to use for parsing the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeParseJSON<T>(options: {\n  text: string;\n  schema: ZodSchema<T> | Validator<T>;\n}): ParseResult<T>;\nexport function safeParseJSON<T>({\n  text,\n  schema,\n}: {\n  text: string;\n  schema?: ZodSchema<T> | Validator<T>;\n}): ParseResult<T> {\n  try {\n    const value = SecureJSON.parse(text);\n\n    if (schema == null) {\n      return { success: true, value: value as T, rawValue: value };\n    }\n\n    const validationResult = safeValidateTypes({ value, schema });\n\n    return validationResult.success\n      ? { ...validationResult, rawValue: value }\n      : validationResult;\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error)\n        ? error\n        : new JSONParseError({ text, cause: error }),\n    };\n  }\n}\n\nexport function isParsableJson(input: string): boolean {\n  try {\n    SecureJSON.parse(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport { z } from 'zod';\nimport { Validator, asValidator } from './validator';\n\n/**\n * Validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns {T} - The typed object.\n */\nexport function validateTypes<T>({\n  value,\n  schema: inputSchema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}): T {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n\n  return result.value;\n}\n\n/**\n * Safely validates the types of an unknown object using a schema and\n * return a strongly-typed object.\n *\n * @template T - The type of the object to validate.\n * @param {string} options.value - The JSON object to validate.\n * @param {Validator<T>} options.schema - The schema to use for validating the JSON.\n * @returns An object with either a `success` flag and the parsed and typed data, or a `success` flag and an error object.\n */\nexport function safeValidateTypes<T>({\n  value,\n  schema,\n}: {\n  value: unknown;\n  schema: z.Schema<T, z.ZodTypeDef, any> | Validator<T>;\n}):\n  | { success: true; value: T }\n  | { success: false; error: TypeValidationError } {\n  const validator = asValidator(schema);\n\n  try {\n    if (validator.validate == null) {\n      return { success: true, value: value as T };\n    }\n\n    const result = validator.validate(value);\n\n    if (result.success) {\n      return result;\n    }\n\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n    };\n  }\n}\n","import { z } from 'zod';\n\n/**\n * Used to mark validator functions so we can support both Zod and custom schemas.\n */\nexport const validatorSymbol = Symbol.for('vercel.ai.validator');\n\nexport type ValidationResult<OBJECT> =\n  | { success: true; value: OBJECT }\n  | { success: false; error: Error };\n\nexport type Validator<OBJECT = unknown> = {\n  /**\n   * Used to mark validator functions so we can support both Zod and custom schemas.\n   */\n  [validatorSymbol]: true;\n\n  /**\n   * Optional. Validates that the structure of a value matches this schema,\n   * and returns a typed version of the value if it does.\n   */\n  readonly validate?: (value: unknown) => ValidationResult<OBJECT>;\n};\n\n/**\n * Create a validator.\n *\n * @param validate A validation function for the schema.\n */\nexport function validator<OBJECT>(\n  validate?: undefined | ((value: unknown) => ValidationResult<OBJECT>),\n): Validator<OBJECT> {\n  return { [validatorSymbol]: true, validate };\n}\n\nexport function isValidator(value: unknown): value is Validator {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    validatorSymbol in value &&\n    value[validatorSymbol] === true &&\n    'validate' in value\n  );\n}\n\nexport function asValidator<OBJECT>(\n  value: Validator<OBJECT> | z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return isValidator(value) ? value : zodValidator(value);\n}\n\nexport function zodValidator<OBJECT>(\n  zodSchema: z.Schema<OBJECT, z.ZodTypeDef, any>,\n): Validator<OBJECT> {\n  return validator(value => {\n    const result = zodSchema.safeParse(value);\n    return result.success\n      ? { success: true, value: result.data }\n      : { success: false, error: result.error };\n  });\n}\n","import { InvalidArgumentError } from '@ai-sdk/provider';\nimport { safeValidateTypes } from './validate-types';\nimport { z } from 'zod';\n\nexport function parseProviderOptions<T>({\n  provider,\n  providerOptions,\n  schema,\n}: {\n  provider: string;\n  providerOptions: Record<string, unknown> | undefined;\n  schema: z.ZodSchema<T>;\n}): T | undefined {\n  if (providerOptions?.[provider] == null) {\n    return undefined;\n  }\n\n  const parsedProviderOptions = safeValidateTypes({\n    value: providerOptions[provider],\n    schema,\n  });\n\n  if (!parsedProviderOptions.success) {\n    throw new InvalidArgumentError({\n      argument: 'providerOptions',\n      message: `invalid ${provider} provider options`,\n      cause: parsedProviderOptions.error,\n    });\n  }\n\n  return parsedProviderOptions.value;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { FetchFunction } from './fetch-function';\nimport { isAbortError } from './is-abort-error';\nimport { removeUndefinedEntries } from './remove-undefined-entries';\nimport { ResponseHandler } from './response-handler';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => globalThis.fetch;\n\nexport const postJsonToApi = async <T>({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch,\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: unknown;\n  failedResponseHandler: ResponseHandler<APICallError>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) =>\n  postToApi({\n    url,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n    body: {\n      content: JSON.stringify(body),\n      values: body,\n    },\n    failedResponseHandler,\n    successfulResponseHandler,\n    abortSignal,\n    fetch,\n  });\n\nexport const postToApi = async <T>({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch(),\n}: {\n  url: string;\n  headers?: Record<string, string | undefined>;\n  body: {\n    content: string | FormData | Uint8Array;\n    values: unknown;\n  };\n  failedResponseHandler: ResponseHandler<Error>;\n  successfulResponseHandler: ResponseHandler<T>;\n  abortSignal?: AbortSignal;\n  fetch?: FetchFunction;\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.ok) {\n      let errorInformation: {\n        value: Error;\n        responseHeaders?: Record<string, string> | undefined;\n      };\n\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values,\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n\n        throw new APICallError({\n          message: 'Failed to process error response',\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values,\n        });\n      }\n\n      throw errorInformation.value;\n    }\n\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values,\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n\n      throw new APICallError({\n        message: 'Failed to process successful response',\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values,\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n\n    // unwrap original error when fetch failed (for easier debugging):\n    if (error instanceof TypeError && error.message === 'fetch failed') {\n      const cause = (error as any).cause;\n\n      if (cause != null) {\n        // Failed to connect to server:\n        throw new APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true, // retry when network error\n        });\n      }\n    }\n\n    throw error;\n  }\n};\n","export type Resolvable<T> =\n  | T // Raw value\n  | Promise<T> // Promise of value\n  | (() => T) // Function returning value\n  | (() => Promise<T>); // Function returning promise of value\n\n/**\n * Resolves a value that could be a raw value, a Promise, a function returning a value,\n * or a function returning a Promise.\n */\nexport async function resolve<T>(value: Resolvable<T>): Promise<T> {\n  // If it's a function, call it to get the value/promise\n  if (typeof value === 'function') {\n    value = (value as Function)();\n  }\n\n  // Otherwise just resolve whatever we got (value or promise)\n  return Promise.resolve(value as T);\n}\n","import { APICallError, EmptyResponseBodyError } from '@ai-sdk/provider';\nimport { ZodSchema } from 'zod';\nimport {\n  createEventSourceParserStream,\n  EventSourceChunk,\n} from './event-source-parser-stream';\nimport { extractResponseHeaders } from './extract-response-headers';\nimport { parseJSON, ParseResult, safeParseJSON } from './parse-json';\n\nexport type ResponseHandler<RETURN_TYPE> = (options: {\n  url: string;\n  requestBodyValues: unknown;\n  response: Response;\n}) => PromiseLike<{\n  value: RETURN_TYPE;\n  rawValue?: unknown;\n  responseHeaders?: Record<string, string>;\n}>;\n\nexport const createJsonErrorResponseHandler =\n  <T>({\n    errorSchema,\n    errorToMessage,\n    isRetryable,\n  }: {\n    errorSchema: ZodSchema<T>;\n    errorToMessage: (error: T) => string;\n    isRetryable?: (response: Response, error?: T) => boolean;\n  }): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n    const responseHeaders = extractResponseHeaders(response);\n\n    // Some providers return an empty response body for some errors:\n    if (responseBody.trim() === '') {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n\n    // resilient parsing in case the response is not JSON or does not match the schema:\n    try {\n      const parsedError = parseJSON({\n        text: responseBody,\n        schema: errorSchema,\n      });\n\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: errorToMessage(parsedError),\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          data: parsedError,\n          isRetryable: isRetryable?.(response, parsedError),\n        }),\n      };\n    } catch (parseError) {\n      return {\n        responseHeaders,\n        value: new APICallError({\n          message: response.statusText,\n          url,\n          requestBodyValues,\n          statusCode: response.status,\n          responseHeaders,\n          responseBody,\n          isRetryable: isRetryable?.(response),\n        }),\n      };\n    }\n  };\n\nexport const createEventSourceResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    return {\n      responseHeaders,\n      value: response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(createEventSourceParserStream())\n        .pipeThrough(\n          new TransformStream<EventSourceChunk, ParseResult<T>>({\n            transform({ data }, controller) {\n              // ignore the 'DONE' event that e.g. OpenAI sends:\n              if (data === '[DONE]') {\n                return;\n              }\n\n              controller.enqueue(\n                safeParseJSON({\n                  text: data,\n                  schema: chunkSchema,\n                }),\n              );\n            },\n          }),\n        ),\n    };\n  };\n\nexport const createJsonStreamResponseHandler =\n  <T>(\n    chunkSchema: ZodSchema<T>,\n  ): ResponseHandler<ReadableStream<ParseResult<T>>> =>\n  async ({ response }: { response: Response }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (response.body == null) {\n      throw new EmptyResponseBodyError({});\n    }\n\n    let buffer = '';\n\n    return {\n      responseHeaders,\n      value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n        new TransformStream<string, ParseResult<T>>({\n          transform(chunkText, controller) {\n            if (chunkText.endsWith('\\n')) {\n              controller.enqueue(\n                safeParseJSON({\n                  text: buffer + chunkText,\n                  schema: chunkSchema,\n                }),\n              );\n              buffer = '';\n            } else {\n              buffer += chunkText;\n            }\n          },\n        }),\n      ),\n    };\n  };\n\nexport const createJsonResponseHandler =\n  <T>(responseSchema: ZodSchema<T>): ResponseHandler<T> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseBody = await response.text();\n\n    const parsedResult = safeParseJSON({\n      text: responseBody,\n      schema: responseSchema,\n    });\n\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!parsedResult.success) {\n      throw new APICallError({\n        message: 'Invalid JSON response',\n        cause: parsedResult.error,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        url,\n        requestBodyValues,\n      });\n    }\n\n    return {\n      responseHeaders,\n      value: parsedResult.value,\n      rawValue: parsedResult.rawValue,\n    };\n  };\n\nexport const createBinaryResponseHandler =\n  (): ResponseHandler<Uint8Array> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n\n    if (!response.body) {\n      throw new APICallError({\n        message: 'Response body is empty',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n      });\n    }\n\n    try {\n      const buffer = await response.arrayBuffer();\n      return {\n        responseHeaders,\n        value: new Uint8Array(buffer),\n      };\n    } catch (error) {\n      throw new APICallError({\n        message: 'Failed to read response as array buffer',\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody: undefined,\n        cause: error,\n      });\n    }\n  };\n\nexport const createStatusCodeErrorResponseHandler =\n  (): ResponseHandler<APICallError> =>\n  async ({ response, url, requestBodyValues }) => {\n    const responseHeaders = extractResponseHeaders(response);\n    const responseBody = await response.text();\n\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues: requestBodyValues as Record<string, unknown>,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n      }),\n    };\n  };\n","// btoa and atob need to be invoked as a function call, not as a method call.\n// Otherwise CloudFlare will throw a\n// \"TypeError: Illegal invocation: function called with incorrect this reference\"\nconst { btoa, atob } = globalThis;\n\nexport function convertBase64ToUint8Array(base64String: string) {\n  const base64Url = base64String.replace(/-/g, '+').replace(/_/g, '/');\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, byte => byte.codePointAt(0)!);\n}\n\nexport function convertUint8ArrayToBase64(array: Uint8Array): string {\n  let latin1string = '';\n\n  // Note: regular for loop to support older JavaScript versions that\n  // do not support for..of on Uint8Array\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n\n  return btoa(latin1string);\n}\n","export function withoutTrailingSlash(url: string | undefined) {\n  return url?.replace(/\\/$/, '');\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}